# ===

#include :: fortran_exec.ebnf

specification_part = { use_stmt } { implicit_stmt } { declaration_construct } ;

use_stmt =
      'use' module_name { ',' rename_clause } eos
    | 'use' module_name ',' 'only' ':' only_clause { ',' only_clause } eos
    ;

rename_clause = identifier '=>' use_name ;

only_clause =
      generic_spec
    | [ identifier '=>' ] use_name
    ;

use_name = identifier ;

implicit_stmt =
      'implicit' 'none' eos
    | 'implicit' implicit_spec ~ { ',' implicit_spec } eos
    ;

implicit_spec = type_spec '(' letter_spec { ',' letter_spec } ')' ;

letter_spec = letter [ '-' letter ] ;

declaration_construct =
	  entity_decl_stmt
	| specification_stmt
	| derived_type_def
	| interface_block
	;

entity_decl_stmt =
    type_spec [ { ',' ~ attr_spec } '::' ~ ] entity_decl_list eos ;

entity_decl_list = entity_decl { ',' entity_decl } ;

entity_decl = entity_name [ '*' char_length ] [ '(' array_spec ')' ] [ initializer ];

entity_name = identifier ;

initializer =
      '=' expr
    | '=>' expr
    ;

attr_spec =
	  'parameter'
	| access_spec
	| 'allocatable'
	| 'dimension' '(' array_spec ')'
	| 'external'
	| 'intent' '(' intent_spec ')'
	| 'intrinsic'
	| 'optional'
	| 'pointer'
	| 'save'
	| 'target'
	| 'value'
	| 'volatile'
	;

specification_stmt =
	  access_stmt
	| allocatable_stmt
	| common_stmt
#	| data_stmt
	| dimension_stmt
#	| equivalence_stmt
	| external_stmt
	| intrinsic_stmt
#	| save_stmt
	| intent_stmt
#	| namelist_stmt
	| optional_stmt
	| pointer_stmt
	| target_stmt
	;


access_stmt =
	  access_spec [ '::' ] generic_spec_or_name { ',' generic_spec_or_name } eos ;

access_spec =
	  'public'
	| 'private'
	;


common_stmt = 'common' common_block { [ ',' ] common_block } eos ;

common_block = [ common_block_tag ] entity_ref { ',' entity_ref } ;

common_block_tag = '/' [ common_block_name ] '/' ;

common_block_name = identifier ;


dimension_stmt = 'dimension' ~ [ '::' ] array_decl { ',' array_decl } eos ;

array_decl = variable '(' array_spec ')' ;



allocatable_stmt =
	  'allocatable' ~ [ '::'  ] entity_ref { ',' entity_ref  } eos ;

intent_stmt = 'intent' '(' intent_spec ')' ~ [ '::' ] dummy_arg_name { ',' dummy_arg_name } eos ;

intent_spec =
	  'in'
	| 'out'
	| 'inout'
	;

optional_stmt = 'optional' ~ [ '::' ] dummy_arg_name { ',' dummy_arg_name } eos ;

pointer_stmt = 'pointer' ~ [ '::' ] entity_ref { ',' entity_ref } eos ;

target_stmt = 'target' ~ [ '::' ] entity_ref { ',' entity_ref } eos ;

entity_ref = entity_name [ '(' deferred_shape_spec_list ')' ] eos ;


external_stmt = 'external' [ '::' ] external_name { ',' external_name } eos ;

external_name = identifier ;

intrinsic_stmt = 'intrinsic' [ '::' ] intrinsic_proc { ',' intrinsic_proc } eos ;

intrinsic_proc = identifier ;


derived_type_def = derived_type_stmt ~ derived_type_body end_type_stmt ;

derived_type_stmt = 'type' [ { ',' access_spec } '::' ] type_name eos ;

derived_type_body = { derived_header } { component_def_stmt } ;

derived_header =
     private_stmt
   | sequence_stmt
   ;

private_stmt = 'private' eos ;

sequence_stmt = 'sequence' eos ;

component_def_stmt =
	  type_spec [ { ',' ~ comp_attr_spec } '::' ] entity_decl { ',' entity_decl } eos;

comp_attr_spec =
	  'pointer'
	| 'dimension' '(' comp_array_spec ')'
	| 'allocatable'
	;

comp_array_spec =
	  explicit_shape_spec_list
	| deferred_shape_spec_list
	;

end_type_stmt = end [ 'type' [ type_name ] ] eos ;


interface_block = interface_stmt { interface_body_part } end_interface_stmt ;

interface_stmt = 'interface' ~ [ generic_spec_or_name ] eos ;

interface_body_part =
	  subprogram
	| module_proc_stmt
	;

end_interface_stmt = 'end' [ 'interface' [ generic_spec_or_name ] ] eos ;


module_proc_stmt = 'module' 'procedure' ~ procedure_name { ',' procedure_name } eos ;

procedure_name = identifier ;


generic_spec_or_name =
	  generic_name
	| generic_spec
	;

generic_spec =
      'operator' bracketed_operator
    | 'assignment' '(' '=' ')'
    ;

generic_name = identifier ;



type_spec =
      intrinsic_type_spec
    | derived_type_spec
    ;

intrinsic_type_spec =
      'integer' [ kind_selector ]
    | 'real' [ kind_selector ]
    | 'double' 'precision'
    | 'complex' [ kind_selector ]
    | 'character' [ char_selector ]
    | 'logical' [ kind_selector ]
    ;

derived_type_spec = 'type' '(' type_name ')' ;

type_name = identifier ;

kind_selector =
      '(' [ 'kind' '=' ] kind ')'
    | '*' int_literal
	;

char_selector =
      length_selector
	| '(' [ 'len' '=' ] length ',' [ 'kind' '=' ] kind ')'
    | '(' 'kind' '=' kind [ ',' 'len' '='  length ] ')'
	;

length_selector =
	  '(' [ 'len' '=' ] length ')'
	| '*' char_length
	;

char_length =
	  '(' length ')'
	| int_literal
	;

kind = expr ;

length = type_param_value ;

type_param_value =
      '*'
    | ':'
    | expr
    ;


array_spec =
      explicit_shape_spec_list
    | deferred_shape_spec_list
    | assumed_shape_spec { ',' assumed_shape_spec }
    | { explicit_shape_spec ',' } implied_shape_spec
    | implied_shape_spec { ',' implied_shape_spec }
    ;

explicit_shape_spec_list =
    explicit_shape_spec { ',' explicit_shape_spec } ;

deferred_shape_spec_list =
    deferred_shape_spec { ',' deferred_shape_spec } ;

explicit_shape_spec = [ lower_bound ':' ] upper_bound ;

deferred_shape_spec = ':' ;

assumed_shape_spec = [ lower_bound ] ':' ;

implied_shape_spec = [ lower_bound ':' ] '*' ;

lower_bound = expr ;

upper_bound = expr ;
