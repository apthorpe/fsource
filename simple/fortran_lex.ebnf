@@grammar :: FortranLex

@@ignorecase :: True

@@whitespace :: /[\t ]*&[\t ]*(?:![^\r\n]*)?(?:\r\n?|\n)[\t ]*(?:&?[\t ]*)|[\t ]+/

# HACK: Tatsu requires keywords to be in uppercase in case-insensitive grammars
@@keyword :: IF ELSEIF ELSE END ENDIF PROGRAM ENDPROGRAM IMPLICIT NONE
@@keyword :: INTEGER REAL DOUBLE PRECISION COMPLEX CHARACTER LOGICAL TYPE ENDTYPE
@@keyword :: OPERATOR ASSIGNMENT COMMON DATA EQUIVALENCE NAMELIST
@@keyword :: SUBROUTINE ENDSUBROUTINE FUNCTION ENDFUNCTION RECURSIVE
@@keyword :: KIND PARAMETER ENTRY RESULT OPTIONAL INTENT
@@keyword :: DIMENSION EXTERNAL INTERNAL INTRINSIC PUBLIC PRIVATE SEQUENCE
@@keyword :: INTERFACE ENDINTERFACE MODULE ENDMODULE USE ONLY CONTAINS
@@keyword :: ALLOCATABLE POINTER SAVE TARGET ALLOCATE DEALLOCATE
@@keyword :: CYCLE EXIT NULLIFY CALL CONTINUE PAUSE RETURN STOP
@@keyword :: FORMAT BACKSPACE CLOSE FILE ENDFILE INQUIRE OPEN PRINT READ WRITE REWIND
@@keyword :: WHERE ENDWHERE ASSIGN TO
@@keyword :: SELECT CASE DEFAULT ENDSELECT
@@keyword :: GO GOTO DO ENDDO WHILE ENDWHILE BLOCK ENDBLOCK

lexer = { token } $ ;

token =
      eol ~ [ line_start_token ]
    | contractives
    | word
    | literal
    | operator
    ;

eol = /(?:![^\r\n]*)?(?:\r\n?|\n)/ ;

line_start_token =
      label
    | preproc_stmt
    ;

label = /\d{1,5}/ ;

preproc_stmt = /#[^\r\n]+/ ;

@name
identifier = word ;

word = /[A-Za-z][A-Za-z0-9_]*/ ;

contractives =
      end
    | go
    | else
    ;

end = /(?i)end(?=\s|if|where|do|while|forall|subroutine|function|program|file|module|block)/ ;

go = /(?i)go(?=\s|to)/ ;

else = /(?i)else(?=\s|if|where)/ ;

literal =
      int_literal
    | string_literal
    | real_literal
    | binary_literal
    | octal_literal
    | hex_literal
    | bool_literal
    ;

int_literal = /\d+(?![A-Za-z0-9]|\.(?![A-Za-z]+\.))/ ;

string_literal = sq_string_literal | dq_string_literal ;

sq_string_literal = /'(?:''|&[ \t]*(?:\r\n?|\n)|[^'\r\n])*'(?!['"\w])/ ;

dq_string_literal = /"(?:""|&[ \t]*(?:\r\n?|\n)|[^"\r\n])*"(?!['"\w])/ ;

real_literal = /(?:(?:\d+\.\d*|\.\d+)(?:[dDeE][-+]?\d+)?|\d+[dDeE][-+]?\d+)(?!['"0-9A-Za-z])/ ;

binary_literal = /[Bb]'[01]+'/ | /[Bb]"[01]+"/ ;

octal_literal = /[Oo]'[0-7]+'/ | /[Oo]"[0-7]+"/ ;

hex_literal = /[Zz]'[0-9A-Fa-f]+'/ | /[Zz]"[0-9A-Fa-f]+"/ ;

bool_literal = /(?i)\.(true|false)\./ ;

operator =
      plus_op
    | mul_op
    | pow_op
    | concat_op
    | open_parens
    | close_parens
    | open_arr_constr
    | close_arr_constr
    | assign_op
    | assign_ptr_op
    | other_op
    | rel_op
    | or_op
    | and_op
    | not_op
    | equiv_op
    | custom_op
    ;

plus_op = /[-+]/ ;

mul_op = /\*(?!\*)|\/(?![\/)=])/ ;

pow_op = '**' ;

concat_op = '//' ;

open_parens = /\((?!\/)/ ;

close_parens = ')' ;

open_arr_constr = '(/' ;

close_arr_constr = '/)' ;

assign_op = /=(?![=>])/ ;

assign_ptr_op = '=>' ;

other_op = /[%$,_:;]/ ;

rel_op = /(?i)\.(?:eq|ne|l[te]|g[te])\.|[\/=]=|<=?|>=?/ ;

or_op = '.or.' ;

and_op = '.and.' ;

not_op = '.not.' ;

equiv_op = /(?i)\.n?eqv\./ ;

custom_op = !intrinsic_dot_expr /\.[A-Za-z]+\./ ;

intrinsic_dot_expr = /(?i)\.(?:eq|ne|l[te]|g[te]|n?eqv|not|and|or|true|false)\./ ;
