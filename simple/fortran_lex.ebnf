@@grammar :: Fortran

@@ignorecase :: True

@@whitespace :: /[\t ]*&[\t ]*(?:![^\r\n]*)?(?:\r\n?|\n)[\t ]*(?:&?[\t ]*)|[\t ]+/

@@namechars :: 'A-Za-z0-9_'

# HACK: Tatsu requires keywords to be in uppercase in case-insensitive grammars
@@keyword :: IF ELSEIF ELSE ENDIF PROGRAM ENDPROGRAM IMPLICIT NONE
@@keyword :: INTEGER DOUBLE PRECISION COMPLEX CHARACTER LOGICAL TYPE ENDTYPE
@@keyword :: OPERATOR ASSIGNMENT COMMON DATA EQUIVALENCE NAMELIST
@@keyword :: SUBROUTINE ENDSUBROUTINE FUNCTION ENDFUNCTION RECURSIVE
@@keyword :: PARAMETER ENTRY RESULT OPTIONAL INTENT
@@keyword :: DIMENSION EXTERNAL INTERNAL INTRINSIC PUBLIC PRIVATE SEQUENCE
@@keyword :: INTERFACE ENDINTERFACE MODULE ENDMODULE USE ONLY CONTAINS
@@keyword :: ALLOCATABLE POINTER SAVE ALLOCATE DEALLOCATE
@@keyword :: CYCLE EXIT NULLIFY CALL CONTINUE PAUSE RETURN STOP
@@keyword :: FORMAT BACKSPACE CLOSE  ENDFILE INQUIRE OPEN PRINT READ WRITE REWIND
@@keyword :: WHERE ENDWHERE ASSIGN TO
@@keyword :: SELECT CASE DEFAULT ENDSELECT
@@keyword :: GO GOTO DO ENDDO WHILE ENDWHILE BLOCK ENDBLOCK

# TODO
# @@keyword :: REAL END FILE

lexer = { token } $ ;

token =
      stmt_sep
    | stmt_token
    ;

stmt_token =
      contractives
    | word
    | literal
    | bracketed_operator
    | operator
    | bracketing
    ;

eos = { stmt_sep }+ | $ ;

stmt_sep =
      eol [ line_start_token ]
    | ';'
    ;

eol = /(?:![^\r\n]*)?(?:\r\n?|\n)/ ;

line_start_token =
      label
    | preproc_stmt
    ;

label = /\d{1,5}/ ;

preproc_stmt = /#[^\r\n]+/ ;

@name
identifier = word ;

word = /[A-Za-z][A-Za-z0-9_]*/ ;

letter = /[A-Za-z]/ ;

contractives =
      end
    | go
    | else
    ;

end = /(?i)end(?=\s|if|where|do|while|forall|subroutine|function|program|file|module|block)/ ;

go = /(?i)go(?=\s|to)/ ;

else = /(?i)else(?=\s|if|where)/ ;

literal =
      int_literal
    | string_literal
    | real_literal
    | binary_literal
    | octal_literal
    | hex_literal
    | bool_literal
    ;

int_literal = /\d+(?![A-Za-z0-9]|\.(?![A-Za-z]+\.))/ ;

string_literal = sq_string_literal | dq_string_literal ;

sq_string_literal = /'(?:''|&[ \t]*(?:\r\n?|\n)|[^'\r\n])*'(?!['"\w])/ ;

dq_string_literal = /"(?:""|&[ \t]*(?:\r\n?|\n)|[^"\r\n])*"(?!['"\w])/ ;

real_literal = /(?:(?:\d+\.\d*|\.\d+)(?:[dDeE][-+]?\d+)?|\d+[dDeE][-+]?\d+)(?!['"0-9A-Za-z])/ ;

binary_literal = /[Bb]'[01]+'/ | /[Bb]"[01]+"/ ;

octal_literal = /[Oo]'[0-7]+'/ | /[Oo]"[0-7]+"/ ;

hex_literal = /[Zz]'[0-9A-Fa-f]+'/ | /[Zz]"[0-9A-Fa-f]+"/ ;

bool_literal = /(?i)\.(true|false)\./ ;

bracketed_operator = '(' ('/' | operator) ')' ;

operator =
      plus_op
    | mul_op
    | pow_op
    | concat_op
    | assign_op
    | assign_ptr_op
    | other_op
    | rel_op
    | or_op
    | and_op
    | not_op
    | equiv_op
    | custom_op
    ;

bracketing =
    | open_parens
    | close_parens
    | open_arr
    | close_arr
    ;

plus_op = /[-+](?![*\/=])/ ;

mul_op = /\*(?!\*)|\/(?![\/)=])/ ;

pow_op = '**' ;

concat_op = '//' ;

open_parens = /\((?!\/)/ ;

close_parens = ')' ;

open_arr = '(/' ;

close_arr = '/)' ;

assign_op = /=(?![=>])/ ;

assign_ptr_op = '=>' ;

other_op = /[%$,_:]/ ;

rel_op = /(?i)\.(?:eq|ne|l[te]|g[te])\.|[\/=]=|<=?|>=?/ ;

or_op = '.or.' ;

and_op = '.and.' ;

not_op = '.not.' ;

equiv_op = /(?i)\.n?eqv\./ ;

custom_op = !intrinsic_dot_expr /\.[A-Za-z]+\./ ;

intrinsic_dot_expr = /(?i)\.(?:eq|ne|l[te]|g[te]|n?eqv|not|and|or|true|false)\./ ;
