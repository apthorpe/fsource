# ====

#include :: fortran_lex.ebnf

expr = level5_expr { custom_binary_op level5_expr } ;

level5_expr = equiv_operand { equiv_op equiv_operand } ;

equiv_operand = or_operand { or_op or_operand } ;

or_operand =  and_operand { and_op and_operand } ;

and_operand = [ not_op ~ ] level4_expr ;

level4_expr = level3_expr { rel_op level3_expr } ;

level3_expr = level2_expr { concat_op level2_expr } ;

# This means one cannot write, e.g., 3*-2 in Fortran
level2_expr = [ plus_op ~ ] add_operand { plus_op add_operand } ;

add_operand = mult_operand { mul_op mult_operand } ;

mult_operand = level1_expr { pow_op level1_expr } ;

level1_expr = [ custom_unary_op ~ ] primary ;

custom_binary_op = custom_op ;

custom_unary_op = custom_op ;

primary =
      open_parens expr close_parens
    | complex_expr
    | inplace_array
    | constant
    | object_ref_or_call
    ;

complex_expr = open_parens expr ',' expr close_parens ;

inplace_array = open_arr array_part { ',' array_part } close_arr ;

array_part =
      expr
    | implied_do
    ;

implied_do = open_parens expr { ',' expr } ',' do_control close_parens ;

do_control = variable '=' expr ',' expr [ ',' expr ] ;

constant =
      int_literal [ kind_suffix ]
    | real_literal [ kind_suffix ]
    | bool_literal [ kind_suffix ]
    | [ kind_prefix ] string_literal
    | binary_literal
    | octal_literal
    | hex_literal
    ;

kind_suffix = '_' kind_param ;

kind_prefix = kind_param '_' ;

kind_param =
      int_literal
    | variable
    ;

object_ref_or_call = object [ part_or_args ] ;

object = { constituent '%' } variable ;

constituent = variable [ part ] ;

# FIXME: make this nicer

part = open_parens subscript { ',' subscript } close_parens ;

part_or_args = open_parens [ subscript { ',' subscript } ] close_parens ;

subscript =
      slice
    | [ variable '='] expr
    ;

slice = [ expr ] ':' [ expr ] [ ':' expr ] ;

variable = identifier ;
