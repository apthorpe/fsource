@@grammar :: Fortran90

@@whitespace :: /[\t ]*&[\t ]*(?:![^\r\n]*)?(?:\r\n?|\n)[\t ]*(?:&?[\t ]*)|[\t ]+/


# ==== SECTION 2

start = executable-program ;

executable_program = [ eos ] { program_unit }+ ;

program_unit =
	  main_program
	| subprogram
	| module
	| block_data
	;

main_program = [ program_stmt ] program_body end_program_stmt ;

subprogram = function_subprogram | subroutine_subprogram ;

function_subprogram = function_stmt [ program_body ] end_function_stmt ;

subroutine_subprogram = subroutine_stmt [ program_body ] end_subroutine_stmt ;

program_body = [ specification_part ] [ execution_part ] [ subprogram_part ] ;

module = module_stmt [ specification_part ] [ subprogram_part ] end_module_stmt ;

block_data = block_data_stmt specification_part end_block_data_stmt ;

specification_part = { use_stmt } { implicit_stmt | declaration_construct } ;

declaration_construct =
	  derived_type_dev
	| interface_block
	| type_declaration_stmt
	| specification_stmt
	| parameter_stmt
	| format_stmt
	| entry_stmt
	| stmt_function_stmt ;

execution_part = { execution_part_construct } ;

execution_part_construct =
	  executable_construct
	| format_stmt
	| data_stmt
	| entry_stmt ;

subprogram_part = contains_stmt { subprogram } ;

specification_stmt =
	  access_stmt
	| allocatable_stmt
	| common_stmt
	| data_stmt
	| dimension_stmt
	| equivalence_stmt
	| external_stmt
	| intent_stmt
	| intrinsic_stmt
	| namelist_stmt
	| optional_stmt
	| pointer_stmt
	| save_stmt
	| target_stmt
	;

executable_construct =
	  action_stmt
	| case_construct
	| do_construct
	| if_construct
	| where_construct
	;

action_stmt =
	  allocate_stmt
	| assignment_stmt
	| backspace_stmt
	| call_stmt
	| close_stmt
	| computed_goto_stmt
	| continue_stmt
	| cycle_stmt
	| deallocate_stmt
	| endfile_stmt
	| exit_stmt
	| goto_stmt
	| if_stmt
	| inquire_stmt
	| nullify_stmt
	| open_stmt
	| pointer_assignment_stmt
	| print_stmt
	| read_stmt
	| return_stmt
	| rewind_stmt
	| stop_stmt
	| where_stmt
	| write_stmt
	| arithmetic_if_stmt
	| assign_stmt
	| assigned_goto_stmt
	| pause_stmt
	;

type_spec =
	  'integer' kind_selector
	| 'real' kind_selector
	| 'double' 'precision'
	| 'complex' kind_selector
	| 'character' char_selector
	| 'logical' kind_selector
	| 'type' '(' type_name ')'
	| 'integer'
	| 'real'
	| 'complex'
	| 'logical'
	| 'character'
	| 'character' length_selector
	;

kind_selector =
	  '(' [ 'kind' '=' ] expr ')'
	| '*' icon
	;

char_selector =
	  '(' 'len' '=' type_param_value ',' 'kind' '=' expr ')'
	| '(' 'len' '=' type_param_value ',' expr ')'
	| '(' 'len' '=' type_param_value ')'
	| '(' [ 'kind' '=' ] expr ')'
	;

length_selector =
	  '(' type_param_value ')'
	| '*' char_length
	;
char_length =
	  '(' type_param_value ')'
	| scalar_int_literal_constant
	;



expr = level5_expr { defined_binary_op level5_expr } ;

defined_binary_op = dop ;

level5_expr = equiv_operand { equiv_op equiv_operand } ;

equiv_op =
	  '.eqv.'
	| '.neqv.'
	;

equiv_operand = or_operand { or_op or_operand } ;

or_op = '.or.' ;

or_operand =  and_operand { and_op and_operand } ;

and_op = '.and.' ;

and_operand = [ not_op ] level4_expr ;

not_op = '.not.' ;

level4_expr = level3_expr { rel_op level3_expr } ;

level3_expr = level2_expr { concat_op level2_expr } ;

concat_op = '//' ;

level2_expr =
	  add_operand { add_op add_operand }
	| sign add_operand
	;

add_op =
	  '+'
	| '-'
	;

add_operand = mult_operand { mult_op mult_operand } ;

mult_op =
	  '*'
	| '/'
	;

mult_operand = level1_expr { power_op level1_expr } ;

level1_expr = [ defined_unary_op ] primary ;

defined_unary_op = dop ;

primary =
	  array_constructor
	| unsigned_arithmetic_constant
	| function_reference
	| name
	| data_ref
	| '(' expr ')'
	| scon
	| logical_constant
	;




eos = /(?:(?:;|(?:![^\r\n]*)?(?:\r\n?|\n))[\t ]*)+/ ;

